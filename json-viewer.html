<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            direction: rtl;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: #2196F3;
            color: white;
            padding: 20px;
        }
        
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .header h1 {
            font-size: 24px;
        }
        
        .file-upload {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .btn-upload {
            padding: 8px 16px;
            background: white;
            color: #2196F3;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .navigation {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .btn {
            padding: 8px 16px;
            background: white;
            color: #2196F3;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #f0f0f0;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .counter {
            color: white;
            font-size: 16px;
        }
        
        .goto-input {
            width: 80px;
            padding: 6px 10px;
            border: 2px solid white;
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
        }
        
        .btn-goto {
            padding: 8px 12px;
            background: #4CAF50;
            color: white;
        }
        
        .btn-goto:hover {
            background: #45a049;
        }
        
        .filter-section {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .filter-label {
            color: white;
            font-size: 14px;
            font-weight: 600;
        }
        
        .filter-select {
            padding: 6px 10px;
            border: 2px solid white;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            color: #333;
            min-width: 120px;
        }
        
        .content {
            padding: 30px;
        }
        
        .main-links {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #2196F3;
        }
        
        .link-column {
            text-align: center;
        }
        
        .main-link {
            display: block;
            font-size: 16px;
            font-weight: 600;
            color: #2196F3;
            text-decoration: none;
            padding: 12px;
            background: #E3F2FD;
            border-radius: 4px;
            transition: background 0.3s;
        }
        
        .main-link:hover {
            background: #BBDEFB;
            text-decoration: none;
        }
        
        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .column {
            display: flex;
            flex-direction: column;
        }
        
        .field-group {
            margin-bottom: 20px;
        }
        
        .field-label {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            display: block;
            font-size: 13px;
        }
        
        .field-value {
            padding: 12px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            line-height: 1.6;
            word-break: break-word;
        }
        
        .match-details {
            background: #FFF9C4;
            border: 2px solid #FBC02D;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .field-value.large {
            min-height: 200px;
        }
        
        .field-value.editable {
            background: white;
            border: 2px solid #2196F3;
            cursor: text;
            min-height: 60px;
        }
        
        input.field-value,
        textarea.field-value,
        select.field-value {
            width: 100%;
            font-family: inherit;
            resize: vertical;
        }
        
        textarea.field-value {
            min-height: 100px;
        }
        
        textarea.field-value.large {
            min-height: 200px;
        }
        
        .highlight-siman {
            font-weight: bold;
            background-color: #FFEB3B;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        .bottom-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #eee;
        }
        
        .llm-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .status-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .link {
            color: #2196F3;
            text-decoration: none;
        }
        
        .link:hover {
            text-decoration: underline;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .status-verified {
            background: #4CAF50;
            color: white;
        }
        
        .status-pending {
            background: #FF9800;
            color: white;
        }
        
        .status-done {
            background: #2196F3;
            color: white;
        }
        
        .actions {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #eee;
            display: flex;
            gap: 10px;
        }
        
        .btn-save {
            background: #4CAF50;
            color: white;
            padding: 12px 24px;
            flex: 1;
        }
        
        .btn-save:hover {
            background: #45a049;
        }
        
        .btn-cancel {
            background: #f44336;
            color: white;
            padding: 12px 24px;
        }
        
        .btn-cancel:hover {
            background: #da190b;
        }
        
        @media (max-width: 768px) {
            .two-column-layout,
            .main-links,
            .bottom-row {
                grid-template-columns: 1fr;
            }
        }
        
        .save-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #4CAF50;
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        
        .save-indicator.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
        
        .footer {
            background: #f5f5f5;
            padding: 15px 20px;
            text-align: center;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #ddd;
        }
        
        .footer-info {
            margin: 5px 0;
        }
        
        .footer-info strong {
            color: #333;
        }
    </style>
</head>
<body>
    <div class="save-indicator" id="saveIndicator">×©×™× ×•×™×™× × ×©××¨×•!</div>
    
    <div class="container">
        <div class="header">
            <div class="header-top">
                <h1>Linking</h1>
                <div class="file-upload">
                    <input type="file" id="serverFileInput" accept=".json" onchange="uploadFileToServer(event)" style="display: none;">
                    <button class="btn btn-upload" id="uploadBtn" onclick="document.getElementById('serverFileInput').click()" disabled>
                        ğŸ“¤ Upload JSON
                    </button>
                    <button class="btn btn-upload" id="downloadBtn" onclick="downloadFromServer()" disabled style="margin-right: 10px;">
                        ğŸ“¥ Download JSON
                    </button>
                    <button class="btn btn-upload" id="forceSaveBtn" onclick="forceSaveToServer()" disabled style="margin-right: 10px; background: #FF9800; color: white;">
                        ğŸ’¾ Force Save
                    </button>
                    <input type="file" id="fileInput" accept=".json" onchange="handleFileUpload(event)" style="display: none;">
                    <label for="fileInput" class="btn btn-upload" style="margin-right: 10px;">ğŸ“ ×‘×—×¨ ×§×•×‘×¥ JSON</label>
                </div>
            </div>
            <div class="navigation">
                <button class="btn" id="prevBtn" onclick="previousItem()">â—„ ×”×§×•×“×</button>
                <span class="counter" id="counter">0 / 0</span>
                <button class="btn" id="nextBtn" onclick="nextItem()">×”×‘× â–º</button>
                <button class="btn" style="background: #4CAF50; color: white; font-weight: bold;" onclick="saveAndNext()">×©××•×¨ ×•×”××©×š â–º</button>
                <span style="color: white; margin: 0 5px;">|</span>
                <input type="number" id="gotoInput" class="goto-input" placeholder="#" min="1">
                <button class="btn btn-goto" onclick="gotoItem()">×¢×‘×•×¨</button>
            </div>
            <div class="filter-section">
                <span class="filter-label">×¡×™× ×•×Ÿ:</span>
                <select id="filterStatus" class="filter-select" onchange="updateFilters()">
                    <option value="">×›×œ ×”×¡×˜×˜×•×¡×™×</option>
                    <option value="Pending">Pending</option>
                    <option value="done">done</option>
                    <option value="verified">verified</option>
                    <option value="rejected">rejected</option>
                </select>
                <select id="filterLLMStatus" class="filter-select" onchange="updateFilters()">
                    <option value="">×›×œ ×”-LLM ×¡×˜×˜×•×¡×™×</option>
                    <option value="not_needed">not_needed</option>
                    <option value="pending">pending</option>
                    <option value="approved">approved</option>
                    <option value="rejected">rejected</option>
                </select>
                <span class="counter" id="filterCounter"></span>
            </div>
            <div class="stats-panel" id="statsPanel" style="display: none;">
                <div class="stat-item">
                    <span class="stat-label">ğŸ“Š Total Records:</span>
                    <span class="stat-value" id="statTotalRecords">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">â³ Pending:</span>
                    <span class="stat-value pending" id="statPending">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">âœ“ Verified:</span>
                    <span class="stat-value success" id="statVerified">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ğŸ’¾ Unsaved:</span>
                    <span class="stat-value" id="statUnsaved">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ğŸ•’ Last Save:</span>
                    <span class="stat-value" id="statLastSave">Never</span>
                </div>
            </div>
        </div>
        
        <div class="content" id="content">
            <p style="text-align: center; padding: 40px; color: #666;">
                ×× × ×‘×—×¨ ×§×•×‘×¥ JSON ×›×“×™ ×œ×”×ª×—×™×œ
            </p>
        </div>
        
        <div class="footer">
            <div class="footer-info" id="filePathInfo"></div>
            <div class="footer-info" id="commitInfo">Loading version info...</div>
        </div>
    </div>

    <script>
        let data = [];
        let currentIndex = 0;
        let hasChanges = false;
        let currentFileName = '';
        let currentFileHandle = null;
        let filteredIndices = [];
        let currentFilteredIndex = -1;
        let username = '';
        let dataVersion = null;
        let isAdmin = false;
        let statsPollingInterval = null;
        let lastStatsUpdate = null;
        let pendingUpdates = [];
        let isProcessingUpdates = false;

        // Handle file upload
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            currentFileName = file.name;
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    data = JSON.parse(e.target.result);
                    if (!Array.isArray(data)) {
                        throw new Error('×”×§×•×‘×¥ ×—×™×™×‘ ×œ×”×›×™×œ ××¢×¨×š ×©×œ ××•×‘×™×™×§×˜×™×');
                    }
                    displayItem(0);
                    updateNavigation();
                    updateFilters();
                } catch (error) {
                    console.error('Error parsing JSON:', error);
                    document.getElementById('content').innerHTML = 
                        `<p style="color: red; text-align: center; padding: 40px;">×©×’×™××” ×‘×§×¨×™××ª ×”×§×•×‘×¥: ${error.message}</p>`;
                }
            };
            
            reader.readAsText(file);
        }

        // Check if user is admin
        async function checkAdminStatus() {
            try {
                const response = await fetch('/health');
                const result = await response.json();
                const adminUser = result.admin_user || 'danny';
                isAdmin = (username === adminUser);
                
                // Enable/disable upload and download buttons
                const uploadBtn = document.getElementById('uploadBtn');
                const downloadBtn = document.getElementById('downloadBtn');
                const forceSaveBtn = document.getElementById('forceSaveBtn');
                
                if (uploadBtn && downloadBtn && forceSaveBtn) {
                    uploadBtn.disabled = !isAdmin;
                    downloadBtn.disabled = !isAdmin;
                    forceSaveBtn.disabled = !isAdmin;
                    
                    if (!isAdmin) {
                        uploadBtn.title = `Only ${adminUser} can upload files`;
                        downloadBtn.title = `Only ${adminUser} can download files`;
                        forceSaveBtn.title = `Only ${adminUser} can force save`;
                    } else {
                        uploadBtn.title = 'Upload new JSON file to server';
                        downloadBtn.title = 'Download current JSON file from server';
                        forceSaveBtn.title = 'Force immediate save to disk (ignores auto-save schedule)';
                    }
                }
            } catch (error) {
                console.error('Failed to check admin status:', error);
            }
        }
        
        // Upload file to server (admin only)
        async function uploadFileToServer(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!isAdmin) {
                alert('Only admin users can upload files');
                return;
            }
            
            try {
                const formData = new FormData();
                formData.append('file', file);
                
                const response = await fetch('/upload', {
                    method: 'POST',
                    headers: {
                        'X-Username': username
                    },
                    body: formData
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    const message = `File uploaded successfully! ${result.items} items loaded.`;
                    const pathInfo = result.saved_to ? `\nSaved to: ${result.saved_to}` : '';
                    alert(message + pathInfo);
                    
                    // Update footer with file path
                    if (result.saved_to) {
                        document.getElementById('filePathInfo').innerHTML = 
                            `<strong>Data file location:</strong> ${result.saved_to}`;
                    }
                    
                    await loadDataFromServer();
                } else {
                    alert(`Upload failed: ${result.detail || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Upload error:', error);
                alert('Failed to upload file. Check console for details.');
            }
            
            // Reset file input
            event.target.value = '';
        }
        
        // Download file from server (admin only)
        async function downloadFromServer() {
            if (!isAdmin) {
                alert('Only admin users can download files');
                return;
            }
            
            try {
                const response = await fetch('/download', {
                    headers: {
                        'X-Username': username
                    }
                });
                
                if (response.ok) {
                    const filePath = response.headers.get('X-File-Path');
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    a.download = `tmp_lh_links_${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    
                    // Show file path info
                    if (filePath) {
                        alert(`File downloaded from: ${filePath}`);
                        document.getElementById('filePathInfo').innerHTML = 
                            `<strong>Data file location:</strong> ${filePath}`;
                    }
                } else {
                    const result = await response.json();
                    alert(`Download failed: ${result.detail || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Download error:', error);
                alert('Failed to download file. Check console for details.');
            }
        }
        
        // Force save to server (admin only)
        async function forceSaveToServer() {
            if (!isAdmin) {
                alert('Only admin users can force save');
                return;
            }
            
            if (!confirm('Force save all unsaved changes to disk now?')) {
                return;
            }
            
            try {
                showSaveIndicator('ğŸ’¾ Saving to disk...', 'warning', 3000);
                
                const response = await fetch('/force-save', {
                    method: 'POST',
                    headers: {
                        'X-Username': username
                    }
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showSaveIndicator(`âœ… ${result.message}`, 'success', 3000);
                    // Update stats to show changes were saved
                    await updateStats();
                } else {
                    showSaveIndicator(`âŒ ${result.detail || 'Save failed'}`, 'error', 5000);
                }
            } catch (error) {
                console.error('Force save error:', error);
                showSaveIndicator('âŒ Failed to force save. Check console for details.', 'error', 5000);
            }
        }
        
        // Load data from server (for server mode)
        async function loadDataFromServer() {
            // Prompt for username
            if (!username) {
                username = prompt('Enter your username:', '');
                if (!username) {
                    alert('Username is required to use the application');
                    return;
                }
            }
            
            try {
                const response = await fetch('/data', {
                    headers: {
                        'X-Username': username
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                // Check if reload is required (due to upload by another user)
                if (result.reload_required) {
                    alert('âš ï¸ Data has been updated by another user. Reloading...');
                }
                
                data = result.data || result;
                dataVersion = result.version;
                
                if (!Array.isArray(data)) {
                    throw new Error('Invalid data format');
                }
                
                displayItem(0);
                updateNavigation();
                updateFilters();
                
                // Update stats once on initial load
                await updateStats();
                
                // Show save error if any
                if (result.save_error) {
                    showSaveIndicator('âš ï¸ ' + result.save_error, 'error', 5000);
                }
                
                // Hide local file picker in server mode (keep upload/download buttons visible)
                const localFilePicker = document.getElementById('fileInput');
                const localFileLabel = document.querySelector('label[for="fileInput"]');
                if (localFilePicker) localFilePicker.style.display = 'none';
                if (localFileLabel) localFileLabel.style.display = 'none';
                
                // Update header with username
                const header = document.querySelector('.header h1');
                header.textContent = `Linking (User: ${username})`;
                
                // Check admin status and enable/disable buttons
                checkAdminStatus();
            } catch (error) {
                console.error('Server mode not available:', error);
                // File upload mode will be used instead
            }
        }

        function displayItem(index) {
            if (!data || data.length === 0) return;
            
            currentIndex = index;
            const item = data[index];
            
            // Main header links
            let html = `
                <div class="main-links">
                    <div class="link-column">
                        <a href="${item.RefALink}" target="_blank" class="main-link">${item.RefA}</a>
                    </div>
                    <div class="link-column">
                        <a href="${item.RefBExactLink}" target="_blank" class="main-link">${item.RefBExact}</a>
                    </div>
                </div>
            `;
            
            // Match details section (above snippets, bold)
            html += '<div class="match-details">';
            html += `<strong>Type:</strong> ${item.MatchType} | `;
            html += `<strong>Score:</strong> ${item.DeterministicScore} | `;
            html += `<strong>Matched:</strong> ${item.MatchedWords}`;
            html += '</div>';
            
            // Two column layout for RefA/RefB content
            html += '<div class="two-column-layout">';
            
            // Left column - RefA content
            html += '<div class="column">';
            html += '<div class="field-group">';
            html += '<label class="field-label">Snippet (Likutei Halakhot)</label>';
            
            // Highlight matched words in the snippet
            let snippetText = item.LHSnippet || '';
            let matchedWords = (item.MatchedWords || '').split(' ').filter(w => w.trim());
            let highlightedSnippet = snippetText;
            
            // Extract the chapter number from RefB (e.g., "Likutei Moharan.61" -> 61)
            let refBChapter = null;
            if (item.RefB) {
                const refBParts = item.RefB.split('.');
                if (refBParts.length > 1) {
                    refBChapter = parseInt(refBParts[refBParts.length - 1]);
                }
            }
            
            // Hebrew gematria function to convert Hebrew numbers
            function hebrewGematria(str) {
                const gematriaMap = {
                    '×': 1, '×‘': 2, '×’': 3, '×“': 4, '×”': 5, '×•': 6, '×–': 7, '×—': 8, '×˜': 9,
                    '×™': 10, '×›': 20, '×š': 20, '×œ': 30, '×': 40, '×': 40, '× ': 50, '×Ÿ': 50,
                    '×¡': 60, '×¢': 70, '×¤': 80, '×£': 80, '×¦': 90, '×¥': 90, '×§': 100, '×¨': 200,
                    '×©': 300, '×ª': 400
                };
                let total = 0;
                for (let c of str) {
                    total += gematriaMap[c] || 0;
                }
                return total;
            }
            
            // Highlight "×‘×¡×™××Ÿ" and following words - dark green if matches RefB chapter, light green otherwise
            const simanPattern = /(×¡×™××Ÿ\s+([\u05D0-\u05EA\u0591-\u05C7"×³×´'()]+)(?:\s+[\u05D0-\u05EA\u0591-\u05C7"×³×´'()]+){0,3})/g;
            highlightedSnippet = highlightedSnippet.replace(simanPattern, (match, fullMatch, simanNumber) => {
                // Extract just the Hebrew letters from the siman number
                const cleanSiman = simanNumber.replace(/[\u0591-\u05C7"×³×´'()]/g, '');
                const simanValue = hebrewGematria(cleanSiman);
                
                // Use dark green if it matches the RefB chapter, light green otherwise
                const bgColor = (refBChapter && simanValue === refBChapter) ? '#2e7d32' : '#c8e6c9';
                const textColor = (refBChapter && simanValue === refBChapter) ? 'white' : 'inherit';
                return `<span style="background-color: ${bgColor}; color: ${textColor}; font-weight: bold;">${fullMatch}</span>`;
            });
            
            // Then highlight each matched word with yellow
            matchedWords.forEach(word => {
                if (word) {
                    const regex = new RegExp('(' + word + ')', 'g');
                    highlightedSnippet = highlightedSnippet.replace(regex, '<span class="highlight-siman">$1</span>');
                }
            });
            
            html += `<div class="field-value large" style="white-space: pre-wrap;">${highlightedSnippet}</div>`;
            html += '<button class="btn btn-verify-next" style="margin-top: 15px; padding: 12px 24px; font-size: 16px; font-weight: bold; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;" onclick="verifyAndNext()">âœ“ Mark Verified and Save &gt;&gt;</button>';
            html += '</div>';
            
            html += '</div>';
            
            // Right column - RefB content
            html += '<div class="column">';
            html += '<div class="field-group">';
            html += `<label class="field-label">RefB: <a href="${item.RefBLink}" target="_blank" class="link">${item.RefB}</a></label>`;
            
            // Highlight matched words in LM snippet
            let lmSnippetText = item.LMSnippet || '';
            let highlightedLM = lmSnippetText;
            matchedWords.forEach(word => {
                if (word) {
                    const regex = new RegExp('(' + word + ')', 'g');
                    highlightedLM = highlightedLM.replace(regex, '<span class="highlight-siman">$1</span>');
                }
            });
            
            html += `<div class="field-value large refb-display" style="white-space: pre-wrap;">${highlightedLM}</div>`;
            html += `<textarea class="field-value large editable refb-edit" data-field="LMSnippet" style="display: none;">${lmSnippetText}</textarea>`;
            html += '<button class="btn refb-edit-btn" style="margin-top: 10px;" onclick="toggleRefBEdit()">×¢×¨×•×š</button>';
            html += '</div>';            
            html += '<div class="field-group">';
            html += '<label class="field-label">RefBExact (editable)</label>';
            html += `<input type="text" class="field-value editable" data-field="RefBExact" value="${item.RefBExact || ''}" onfocus="this.select()" onpaste="handleRefBExactPaste(event)" onchange="updateRefBExactLink(this)">`;
            html += '</div>';
            
            html += '<div class="field-group">';
            html += '<label class="field-label" style="font-weight: bold; font-size: 15px;">Status</label>';
            html += '<select class="field-value editable" data-field="Status" style="font-weight: bold;">';
            const statusOptions = ['Pending', 'done', 'verified', 'rejected'];
            statusOptions.forEach(opt => {
                const selected = opt === item.Status ? 'selected' : '';
                html += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            html += '</select>';
            html += '</div>';
            
            html += `
                <div class="actions" style="margin-top: 20px; padding-top: 0; border-top: none;">
                    <button class="btn btn-save" onclick="saveChanges()">×©××•×¨ ×©×™× ×•×™×™×</button>
                    <button class="btn btn-cancel" onclick="cancelChanges()">×‘×˜×œ ×©×™× ×•×™×™×</button>
                </div>
            `;
                        html += '</div>';
            
            html += '</div>'; // End two-column-layout
            
            document.getElementById('content').innerHTML = html;
            
            // Add change listeners
            document.querySelectorAll('.editable').forEach(input => {
                input.addEventListener('change', () => hasChanges = true);
            });
        }

        function updateNavigation() {
            document.getElementById('counter').textContent = `${currentIndex + 1} / ${data.length}`;
            document.getElementById('prevBtn').disabled = currentIndex === 0;
            document.getElementById('nextBtn').disabled = currentIndex === data.length - 1;
            
            // Update based on filters
            if (filteredIndices.length > 0) {
                currentFilteredIndex = filteredIndices.indexOf(currentIndex);
                const hasFilters = document.getElementById('filterStatus').value || document.getElementById('filterLLMStatus').value;
                
                if (hasFilters) {
                    document.getElementById('prevBtn').disabled = currentFilteredIndex <= 0;
                    document.getElementById('nextBtn').disabled = currentFilteredIndex >= filteredIndices.length - 1;
                }
            }
            
            // Update goto input max value
            const gotoInput = document.getElementById('gotoInput');
            if (gotoInput) {
                gotoInput.max = data.length;
            }
        }
        
        function updateFilters() {
            const statusFilter = document.getElementById('filterStatus').value;
            const llmStatusFilter = document.getElementById('filterLLMStatus').value;
            
            // Build filtered indices
            filteredIndices = [];
            for (let i = 0; i < data.length; i++) {
                const item = data[i];
                let matches = true;
                
                if (statusFilter && item.Status !== statusFilter) {
                    matches = false;
                }
                
                if (llmStatusFilter && item.LLMStatus !== llmStatusFilter) {
                    matches = false;
                }
                
                if (matches) {
                    filteredIndices.push(i);
                }
            }
            
            // Update filter counter
            const filterCounter = document.getElementById('filterCounter');
            if (statusFilter || llmStatusFilter) {
                filterCounter.textContent = `(××¦×™×’ ${filteredIndices.length} ××ª×•×š ${data.length})`;
            } else {
                filterCounter.textContent = '';
                filteredIndices = data.map((_, i) => i); // All indices
            }
            
            // Update stats when filter changes
            updateStats();
            
            updateNavigation();
        }
        
        function gotoItem() {
            const input = document.getElementById('gotoInput');
            const itemNumber = parseInt(input.value);
            
            if (isNaN(itemNumber) || itemNumber < 1 || itemNumber > data.length) {
                alert(`× × ×œ×”×–×™×Ÿ ××¡×¤×¨ ×‘×™×Ÿ 1 ×œ-${data.length}`);
                return;
            }
            
            if (hasChanges && !confirm('×™×© ×©×™× ×•×™×™× ×©×œ× × ×©××¨×•. ×”×× ×œ×”××©×™×š?')) {
                return;
            }
            
            displayItem(itemNumber - 1);
            updateNavigation();
            hasChanges = false;
            input.value = ''; // Clear input after navigation
        }

        function previousItem() {
            if (filteredIndices.length > 0 && currentFilteredIndex > 0) {
                if (hasChanges && !confirm('×™×© ×©×™× ×•×™×™× ×©×œ× × ×©××¨×•. ×”×× ×œ×”××©×™×š?')) {
                    return;
                }
                const newIndex = filteredIndices[currentFilteredIndex - 1];
                displayItem(newIndex);
                updateNavigation();
                hasChanges = false;
            } else if (currentIndex > 0 && filteredIndices.length === 0) {
                if (hasChanges && !confirm('×™×© ×©×™× ×•×™×™× ×©×œ× × ×©××¨×•. ×”×× ×œ×”××©×™×š?')) {
                    return;
                }
                displayItem(currentIndex - 1);
                updateNavigation();
                hasChanges = false;
            }
        }

        async function nextItem() {
            if (hasChanges && !confirm('×™×© ×©×™× ×•×™×™× ×©×œ× × ×©××¨×•. ×”×× ×œ×”××©×™×š?')) {
                return;
            }
            
            // Use server-side /next endpoint to avoid collisions
            const filterStatus = document.getElementById('filterStatus')?.value || null;
            const filterLLMStatus = document.getElementById('filterLLMStatus')?.value || null;
            
            try {
                const params = new URLSearchParams({
                    current_index: currentIndex.toString()
                });
                if (filterStatus) params.append('filter_status', filterStatus);
                if (filterLLMStatus) params.append('filter_llm_status', filterLLMStatus);
                
                const response = await fetch(`/next?${params}`, {
                    headers: {
                        'X-Username': username
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.index !== null && result.index !== undefined) {
                    displayItem(result.index);
                    updateNavigation();
                    hasChanges = false;
                    
                    // Update stats after navigation
                    updateLocalStats();
                    
                    // Show info if other users are active
                    if (result.occupied_count > 0) {
                        console.log(`Skipped ${result.occupied_count} records being viewed by other users`);
                    }
                } else {
                    alert(result.message || 'No more records available');
                }
            } catch (error) {
                console.error('Error getting next record:', error);
                // Fallback to client-side logic
                nextItemClientSide();
            }
        }
        
        function nextItemClientSide() {
            // Fallback client-side navigation
            if (filteredIndices.length > 0 && currentFilteredIndex < filteredIndices.length - 1) {
                const newIndex = filteredIndices[currentFilteredIndex + 1];
                displayItem(newIndex);
                updateNavigation();
                hasChanges = false;
            } else if (currentIndex < data.length - 1 && filteredIndices.length === 0) {
                displayItem(currentIndex + 1);
                updateNavigation();
                hasChanges = false;
            }
        }

        function saveChanges() {
            const editableFields = document.querySelectorAll('.editable');
            const updates = {};
            
            editableFields.forEach(input => {
                const fieldName = input.dataset.field;
                const newValue = input.value;
                const oldValue = data[currentIndex][fieldName];
                
                // Track if value changed
                if (newValue !== oldValue) {
                    data[currentIndex][fieldName] = newValue;
                    updates[fieldName] = newValue;
                }
            });
            
            // If there are changes, queue the update
            if (Object.keys(updates).length > 0) {
                // Try server update first (batched, fast)
                if (username && dataVersion) {
                    queueUpdate(currentIndex, updates);
                    showSaveIndicator('âœ“ ×©×™× ×•×™×™× × ×©××¨×•', 'success', 1000);
                } else {
                    // Fallback to full save for local mode
                    saveToFile();
                }
            }
            
            hasChanges = false;
        }

        function cancelChanges() {
            if (hasChanges && !confirm('×”×× ×œ×‘×˜×œ ××ª ×›×œ ×”×©×™× ×•×™×™×?')) {
                return;
            }
            displayItem(currentIndex);
            hasChanges = false;
        }

        function saveAndNext() {
            saveChanges();
            // Update local stats immediately (no server wait)
            updateLocalStats();
            // Wait a bit for save to complete, then move to next
            setTimeout(() => {
                nextItem();
            }, 100);
        }

        function verifyAndNext() {
            // Set status to verified
            const statusSelect = document.querySelector('select[data-field="Status"]');
            if (statusSelect) {
                const oldStatus = data[currentIndex].Status;
                
                // Queue the update to server BEFORE updating local data
                if (oldStatus !== 'verified') {
                    queueUpdate(currentIndex, { Status: 'verified' });
                }
                
                // Update local state
                statusSelect.value = 'verified';
                data[currentIndex].Status = 'verified';
            }
            
            // Also save any other changes in fields (like manually edited fields)
            saveChanges();
            
            // Update local stats immediately (no server wait)
            updateLocalStats();
            
            // Wait a bit for save to complete, then move to next
            setTimeout(() => {
                nextItem();
            }, 100);
        }

        function toggleSnippetEdit() {
            const displayDiv = document.querySelector('.column .field-value.large:not(textarea)');
            const editArea = document.querySelector('.column textarea[data-field="LHSnippet"]');
            const button = document.querySelector('.column button');
            
            if (editArea.style.display === 'none') {
                // Switch to edit mode
                displayDiv.style.display = 'none';
                editArea.style.display = 'block';
                button.textContent = '×©××•×¨';
            } else {
                // Switch to display mode
                const snippetText = editArea.value;
                const highlightedSnippet = snippetText.replace(/(\S*×¡×™××Ÿ\S*)/g, '<span class="highlight-siman">$1</span>');
                displayDiv.innerHTML = highlightedSnippet;
                displayDiv.style.display = 'block';
                editArea.style.display = 'none';
                button.textContent = '×¢×¨×•×š';
                hasChanges = true;
            }
        }

        function toggleRefBEdit() {
            const displayDiv = document.querySelector('.refb-display');
            const editArea = document.querySelector('.refb-edit');
            const button = document.querySelector('.refb-edit-btn');
            
            if (editArea.style.display === 'none') {
                // Switch to edit mode
                displayDiv.style.display = 'none';
                editArea.style.display = 'block';
                button.textContent = '×©××•×¨';
            } else {
                // Switch to display mode
                displayDiv.textContent = editArea.value;
                displayDiv.style.display = 'block';
                editArea.style.display = 'none';
                button.textContent = '×¢×¨×•×š';
                hasChanges = true;
            }
        }

        function updateRefBExactLink(input) {
            const newValue = input.value.trim();
            
            // Check if it's a URL (contains sefaria.org or starts with http)
            if (newValue.includes('sefaria.org') || newValue.startsWith('http')) {
                try {
                    // Parse the URL and remove query parameters
                    const url = new URL(newValue);
                    const pathParts = url.pathname.split('/').filter(p => p);
                    
                    // Extract the reference (usually the last part of the path)
                    if (pathParts.length > 0) {
                        const ref = decodeURIComponent(pathParts[pathParts.length - 1]);
                        
                        // Update RefBExact with the cleaned reference
                        input.value = ref;
                        data[currentIndex].RefBExact = ref;
                        
                        // Construct the clean link without query params
                        const cleanLink = url.origin + url.pathname;
                        data[currentIndex].RefBExactLink = cleanLink;
                        
                        hasChanges = true;
                    }
                } catch (e) {
                    console.error('Error parsing URL:', e);
                }
            } else {
                // If not a URL, just update RefBExact normally
                data[currentIndex].RefBExact = newValue;
                hasChanges = true;
            }
        }

        function handleRefBExactPaste(event) {
            event.preventDefault();
            const pastedText = (event.clipboardData || window.clipboardData).getData('text').trim();
            const input = event.target;
            
            console.log('Pasted text:', pastedText);
            
            // Check if it's a Sefaria URL
            if (pastedText.includes('sefaria.org')) {
                try {
                    // Parse the URL and remove query parameters
                    const url = new URL(pastedText);
                    console.log('Parsed URL:', url);
                    console.log('Pathname:', url.pathname);
                    
                    const pathParts = url.pathname.split('/').filter(p => p);
                    console.log('Path parts:', pathParts);
                    
                    // Extract the reference (usually the last part of the path)
                    if (pathParts.length > 0) {
                        const ref = decodeURIComponent(pathParts[pathParts.length - 1]);
                        
                        // Update the input field with the cleaned reference
                        input.value = ref;
                        
                        // Construct the clean link without query params
                        const cleanLink = url.origin + url.pathname;
                        
                        // Update the RefBExactLink field if it exists
                        const linkField = document.querySelector('input[data-field="RefBExactLink"]');
                        if (linkField) {
                            linkField.value = cleanLink;
                        }
                        
                        // Mark that we have unsaved changes
                        hasChanges = true;
                        
                        // Fetch the LM snippet from the server
                        fetch(`/lm-paragraph/${encodeURIComponent(ref)}`)
                            .then(response => response.json())
                            .then(result => {
                                if (result.text) {
                                    // Update the UI elements (but NOT data[currentIndex] yet)
                                    const refbDisplay = document.querySelector('.refb-display');
                                    const refbEdit = document.querySelector('.refb-edit');
                                    const refbEditBtn = document.querySelector('.refb-edit-btn');
                                    
                                    // Make sure display mode is shown, not edit mode
                                    if (refbDisplay && refbEdit) {
                                        // Update the textarea value so saveChanges() can detect it
                                        refbEdit.value = result.text;
                                        
                                        // Highlight matched words in the snippet
                                        let matchedWords = (data[currentIndex].MatchedWords || '').split(' ').filter(w => w.trim());
                                        let highlightedText = result.text;
                                        matchedWords.forEach(word => {
                                            if (word) {
                                                const regex = new RegExp('(' + word + ')', 'g');
                                                highlightedText = highlightedText.replace(regex, '<span class="highlight-siman">$1</span>');
                                            }
                                        });
                                        
                                        // Update display area
                                        refbDisplay.innerHTML = highlightedText;
                                        
                                        // Ensure display mode is visible
                                        refbDisplay.style.display = 'block';
                                        refbEdit.style.display = 'none';
                                        if (refbEditBtn) refbEditBtn.textContent = '×¢×¨×•×š';
                                    }
                                    
                                    console.log('âœ“ Fetched and updated LMSnippet');
                                } else {
                                    console.warn('No text found for reference:', ref);
                                    // Clear the snippet field on error
                                    const refbEdit = document.querySelector('.refb-edit');
                                    if (refbEdit) {
                                        refbEdit.value = '';
                                    }
                                }
                            })
                            .catch(error => {
                                console.error('Error fetching LM paragraph:', error);
                                // Clear the snippet on error
                                const refbDisplay = document.querySelector('.refb-display');
                                const refbEdit = document.querySelector('.refb-edit');
                                if (refbEdit) {
                                    refbEdit.value = '';
                                }
                                if (refbDisplay) {
                                    refbDisplay.textContent = 'Error fetching paragraph: ' + error.message;
                                    refbDisplay.style.display = 'block';
                                }
                                if (refbEdit) {
                                    refbEdit.value = '';
                                    refbEdit.style.display = 'none';
                                }
                            });
                        
                        // Change status to verified
                        data[currentIndex].Status = 'verified';
                        
                        hasChanges = true;
                        
                        // Update the status dropdown
                        const statusSelect = document.querySelector('select[data-field="Status"]');
                        if (statusSelect) statusSelect.value = 'verified';
                        
                        // Update the main link button at the top
                        const mainLinkButtons = document.querySelectorAll('.main-link');
                        if (mainLinkButtons.length >= 2) {
                            const refBExactLinkButton = mainLinkButtons[1]; // Second link is RefBExact
                            refBExactLinkButton.href = cleanLink;
                            refBExactLinkButton.textContent = ref;
                        }
                        
                        console.log('âœ“ Extracted RefBExact:', ref);
                        console.log('âœ“ Clean link:', cleanLink);
                        console.log('âœ“ Cleared LMSnippet');
                        console.log('âœ“ Status set to verified');
                        console.log('âœ“ Updated main link button');
                        
                        // Flash the input to show it worked
                        input.style.backgroundColor = '#c8e6c9';
                        setTimeout(() => {
                            input.style.backgroundColor = '';
                        }, 500);
                    }
                } catch (e) {
                    console.error('Error parsing URL:', e);
                    // Fallback to normal paste
                    input.value = pastedText;
                }
            } else {
                // Normal paste for non-URL text
                console.log('Not a Sefaria URL, pasting normally');
                input.value = pastedText;
                data[currentIndex].RefBExact = pastedText;
                hasChanges = true;
            }
        }

        async function saveToFile() {
            try {
                const jsonString = JSON.stringify(data, null, 2);
                
                // Try server mode first
                try {
                    const response = await fetch('/save', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Username': username,
                            'X-Data-Version': dataVersion
                        },
                        body: jsonString
                    });
                    
                    if (response.status === 409) {
                        // Conflict detected
                        const result = await response.json();
                        if (confirm('×”×©×™× ×•×™×™× ×©×œ×š ××ª× ×’×©×™× ×¢× ×©×™× ×•×™×™× ×©×œ ××©×ª××© ××—×¨. ×”×× ×œ×˜×¢×•×Ÿ ××—×“×© ××ª ×”× ×ª×•× ×™×? (×©×™× ×•×™×™× ×©×œ× × ×©××¨×• ×™××‘×“×•)')) {
                            await loadDataFromServer();
                        }
                        return;
                    }
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('File saved to server:', result);
                        
                        // Update version
                        dataVersion = result.version;
                        
                        // Show success indicator
                        const indicator = document.getElementById('saveIndicator');
                        indicator.textContent = '× ×©××¨ ×‘×”×¦×œ×—×”!';
                        indicator.classList.add('show');
                        setTimeout(() => indicator.classList.remove('show'), 2000);
                        return;
                    }
                } catch (serverError) {
                    console.log('Server save not available, using download');
                }
                
                // Fallback: download the file
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFileName || 'tmp_lh_links.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('File downloaded');
            } catch (error) {
                console.error('Error saving file:', error);
                alert('×©×’×™××” ×‘×©××™×¨×ª ×”×§×•×‘×¥. ×× × ×‘×“×•×§ ××ª ×”×§×•× ×¡×•×œ.');
            }
        }

        // Stats polling and display functions
        async function updateStats() {
            // First update local stats immediately
            updateLocalStats();
            
            // Then fetch server stats
            try {
                const response = await fetch('/stats', {
                    headers: {
                        'X-Username': username
                    }
                });
                
                if (response.ok) {
                    const stats = await response.json();
                    lastStatsUpdate = stats;
                    
                    const unsavedEl = document.getElementById('statUnsaved');
                    const lastSaveEl = document.getElementById('statLastSave');
                    
                    if (unsavedEl) {
                        unsavedEl.textContent = stats.unsaved_changes || 0;
                        if (stats.unsaved_changes > 5) {
                            unsavedEl.classList.add('pending');
                        } else {
                            unsavedEl.classList.remove('pending');
                        }
                    }
                    
                    // Format last save time
                    if (stats.last_save && lastSaveEl) {
                        const lastSave = new Date(stats.last_save);
                        const now = new Date();
                        const diffMinutes = Math.floor((now - lastSave) / 60000);
                        let timeStr = diffMinutes === 0 ? 'Just now' : 
                                     diffMinutes === 1 ? '1 min ago' :
                                     diffMinutes < 60 ? `${diffMinutes} mins ago` :
                                     lastSave.toLocaleTimeString();
                        lastSaveEl.textContent = timeStr;
                    } else if (lastSaveEl) {
                        lastSaveEl.textContent = 'Never';
                    }
                    
                    if (stats.last_save_error) {
                        showSaveIndicator('âš ï¸ Auto-save failed: ' + stats.last_save_error, 'error', 5000);
                    }
                    
                    document.getElementById('statsPanel').style.display = 'flex';
                }
            } catch (error) {
                console.error('Failed to fetch server stats:', error);
                document.getElementById('statsPanel').style.display = 'flex';
            }
        }
        
        function updateLocalStats() {
            const statusCounts = {};
            data.forEach(item => {
                const status = item.Status || 'unknown';
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });
            
            console.log('Local stats:', statusCounts);
            
            const totalEl = document.getElementById('statTotalRecords');
            const pendingEl = document.getElementById('statPending');
            const verifiedEl = document.getElementById('statVerified');
            
            if (totalEl) totalEl.textContent = data.length || 0;
            if (pendingEl) pendingEl.textContent = statusCounts.Pending || statusCounts.pending || 0;
            if (verifiedEl) verifiedEl.textContent = statusCounts.verified || 0;
            
            const panel = document.getElementById('statsPanel');
            if (panel) panel.style.display = 'flex';
        }
        
        async function checkReloadRequired() {
            try {
                const response = await fetch('/data', {
                    headers: {
                        'X-Username': username
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.reload_required) {
                        if (confirm('âš ï¸ Data has been updated by admin. Reload now?')) {
                            location.reload();
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to check reload status:', error);
            }
        }
        
        function showSaveIndicator(message, type = 'success', duration = 2000) {
            const indicator = document.getElementById('saveIndicator');
            indicator.textContent = message;
            indicator.className = 'save-indicator show';
            
            if (type === 'warning') {
                indicator.classList.add('warning');
            } else if (type === 'error') {
                indicator.classList.add('error');
            }
            
            setTimeout(() => {
                indicator.classList.remove('show');
                setTimeout(() => {
                    indicator.className = 'save-indicator';
                }, 300);
            }, duration);
        }
        
        // Batched update system - queues updates and sends them efficiently
        async function queueUpdate(index, updates) {
            pendingUpdates.push({ index, updates });
            
            // Process updates if not already processing
            if (!isProcessingUpdates) {
                processUpdates();
            }
        }
        
        async function processUpdates() {
            if (pendingUpdates.length === 0) {
                isProcessingUpdates = false;
                return;
            }
            
            isProcessingUpdates = true;
            
            // Get next update from queue
            const update = pendingUpdates.shift();
            
            try {
                const response = await fetch('/update', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Username': username
                    },
                    body: JSON.stringify(update)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    dataVersion = result.version;
                    
                    // Show minimal feedback
                    if (result.modification_count % 5 === 0) {
                        showSaveIndicator(`âœ“ ${result.modification_count} changes queued`, 'success', 1000);
                        // Update stats on every 5th change
                        updateStats();
                    }
                } else {
                    console.error('Update failed:', await response.text());
                    showSaveIndicator('âš ï¸ Update failed', 'error', 2000);
                }
            } catch (error) {
                console.error('Update error:', error);
                showSaveIndicator('âš ï¸ Update error', 'error', 2000);
            }
            
            // Continue processing if there are more updates
            setTimeout(() => processUpdates(), 50);
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    nextItem();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    previousItem();
                } else if (e.key === 's') {
                    e.preventDefault();
                    saveChanges();
                } else if (e.key === 'g') {
                    e.preventDefault();
                    document.getElementById('gotoInput').focus();
                }
            } else if (e.shiftKey && e.key === 'Enter') {
                e.preventDefault();
                saveAndNext();
            } else if (e.key === 'Enter' && document.activeElement.id === 'gotoInput') {
                e.preventDefault();
                gotoItem();
            }
        });

        // Initialize on page load
        window.onload = function() {
            // Load commit info
            loadCommitInfo();
            
            // Try to load from server first
            loadDataFromServer().catch(() => {
                console.log('JSON Viewer loaded. Please select a file to begin.');
            });
        };
        
        // Load git commit information
        async function loadCommitInfo() {
            try {
                const response = await fetch('/health');
                if (response.ok) {
                    const data = await response.json();
                    // Try to get commit from environment or build info
                    const commitInfo = data.commit || data.version || 'unknown';
                    document.getElementById('commitInfo').innerHTML = 
                        `<strong>Version:</strong> ${commitInfo.substring(0, 8)} | <strong>Updated:</strong> ${new Date(data.timestamp).toLocaleString()}`;
                }
            } catch (error) {
                console.log('Could not load commit info:', error);
                document.getElementById('commitInfo').textContent = '';
            }
        }
    </script>
</body>
</html>