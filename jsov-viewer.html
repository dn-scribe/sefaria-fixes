<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            direction: rtl;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: #2196F3;
            color: white;
            padding: 20px;
        }
        
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .header h1 {
            font-size: 24px;
        }
        
        .file-upload {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .btn-upload {
            padding: 8px 16px;
            background: white;
            color: #2196F3;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .navigation {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .btn {
            padding: 8px 16px;
            background: white;
            color: #2196F3;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #f0f0f0;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .counter {
            color: white;
            font-size: 16px;
        }
        
        .goto-input {
            width: 80px;
            padding: 6px 10px;
            border: 2px solid white;
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
        }
        
        .btn-goto {
            padding: 8px 12px;
            background: #4CAF50;
            color: white;
        }
        
        .btn-goto:hover {
            background: #45a049;
        }
        
        .filter-section {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .filter-label {
            color: white;
            font-size: 14px;
            font-weight: 600;
        }
        
        .filter-select {
            padding: 6px 10px;
            border: 2px solid white;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            color: #333;
            min-width: 120px;
        }
        
        .content {
            padding: 30px;
        }
        
        .main-links {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #2196F3;
        }
        
        .link-column {
            text-align: center;
        }
        
        .main-link {
            display: block;
            font-size: 16px;
            font-weight: 600;
            color: #2196F3;
            text-decoration: none;
            padding: 12px;
            background: #E3F2FD;
            border-radius: 4px;
            transition: background 0.3s;
        }
        
        .main-link:hover {
            background: #BBDEFB;
            text-decoration: none;
        }
        
        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .column {
            display: flex;
            flex-direction: column;
        }
        
        .field-group {
            margin-bottom: 20px;
        }
        
        .field-label {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            display: block;
            font-size: 13px;
        }
        
        .field-value {
            padding: 12px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            line-height: 1.6;
            word-break: break-word;
        }
        
        .match-details {
            background: #FFF9C4;
            border: 2px solid #FBC02D;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .field-value.large {
            min-height: 200px;
        }
        
        .field-value.editable {
            background: white;
            border: 2px solid #2196F3;
            cursor: text;
            min-height: 60px;
        }
        
        input.field-value,
        textarea.field-value,
        select.field-value {
            width: 100%;
            font-family: inherit;
            resize: vertical;
        }
        
        textarea.field-value {
            min-height: 100px;
        }
        
        textarea.field-value.large {
            min-height: 200px;
        }
        
        .highlight-siman {
            font-weight: bold;
            background-color: #FFEB3B;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        .bottom-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #eee;
        }
        
        .llm-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .status-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .link {
            color: #2196F3;
            text-decoration: none;
        }
        
        .link:hover {
            text-decoration: underline;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .status-verified {
            background: #4CAF50;
            color: white;
        }
        
        .status-pending {
            background: #FF9800;
            color: white;
        }
        
        .status-done {
            background: #2196F3;
            color: white;
        }
        
        .actions {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #eee;
            display: flex;
            gap: 10px;
        }
        
        .btn-save {
            background: #4CAF50;
            color: white;
            padding: 12px 24px;
            flex: 1;
        }
        
        .btn-save:hover {
            background: #45a049;
        }
        
        .btn-cancel {
            background: #f44336;
            color: white;
            padding: 12px 24px;
        }
        
        .btn-cancel:hover {
            background: #da190b;
        }
        
        @media (max-width: 768px) {
            .two-column-layout,
            .main-links,
            .bottom-row {
                grid-template-columns: 1fr;
            }
        }
        
        .save-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #4CAF50;
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }
        
        .save-indicator.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }
        
        .save-indicator.warning {
            background: #FF9800;
        }
        
        .save-indicator.error {
            background: #f44336;
        }
        
        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
        
        .footer {
            background: #f5f5f5;
            padding: 15px 20px;
            text-align: center;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #ddd;
        }
        
        .footer-info {
            margin: 5px 0;
        }
        
        .footer-info strong {
            color: #333;
        }
    </style>
</head>
<body>
    <div class="save-indicator" id="saveIndicator">×©×™× ×•×™×™× × ×©××¨×•!</div>
    
    <div class="container">
        <div class="header">
            <div class="header-top">
                <h1>Linking</h1>
                <div class="file-upload">
                    <input type="file" id="serverFileInput" accept=".json" onchange="uploadFileToServer(event)" style="display: none;">
                    <button class="btn btn-upload" id="uploadBtn" onclick="document.getElementById('serverFileInput').click()" disabled>
                        ğŸ“¤ Upload JSON
                    </button>
                    <button class="btn btn-upload" id="downloadBtn" onclick="downloadFromServer()" disabled style="margin-right: 10px;">
                        ğŸ“¥ Download JSON
                    </button>
                    <button class="btn btn-upload" id="forceSaveBtn" onclick="forceSaveToServer()" disabled style="margin-right: 10px; background: #FF9800; color: white;">
                        ğŸ’¾ Force Save
                    </button>
                </div>
            </div>
            <div class="navigation">
                <button class="btn" id="prevBtn" onclick="previousItem()">â—„ ×”×§×•×“×</button>
                <span class="counter" id="counter">0 / 0</span>
                <button class="btn" id="nextBtn" onclick="nextItem()">×”×‘× â–º</button>
                <button class="btn" style="background: #4CAF50; color: white; font-weight: bold;" onclick="saveAndNext()">×©××•×¨ ×•×”××©×š â–º</button>
                <span style="color: white; margin: 0 5px;">|</span>
                <input type="number" id="gotoInput" class="goto-input" placeholder="#" min="1">
                <button class="btn btn-goto" onclick="gotoItem()">×¢×‘×•×¨</button>
            </div>
            <div class="filter-section">
                <span class="filter-label">×¡×™× ×•×Ÿ:</span>
                <select id="filterStatus" class="filter-select" onchange="updateFilters()">
                    <option value="">×›×œ ×”×¡×˜×˜×•×¡×™×</option>
                    <option value="Pending">Pending</option>
                    <option value="done">done</option>
                    <option value="verified">verified</option>
                    <option value="rejected">rejected</option>
                </select>
                <select id="filterLLMStatus" class="filter-select" onchange="updateFilters()">
                    <option value="">×›×œ ×”-LLM ×¡×˜×˜×•×¡×™×</option>
                    <option value="not_needed">not_needed</option>
                    <option value="pending">pending</option>
                    <option value="approved">approved</option>
                    <option value="rejected">rejected</option>
                </select>
                <span class="counter" id="filterCounter"></span>
            </div>
            <div class="stats-panel" id="statsPanel" style="display: none;">
                <div class="stat-item">
                    <span class="stat-label">ğŸ“Š Total Records:</span>
                    <span class="stat-value" id="statTotalRecords">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">â³ Pending:</span>
                    <span class="stat-value pending" id="statPending">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">âœ“ Verified:</span>
                    <span class="stat-value success" id="statVerified">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ğŸ’¾ Unsaved:</span>
                    <span class="stat-value" id="statUnsaved">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ğŸ•’ Last Save:</span>
                    <span class="stat-value" id="statLastSave">Never</span>
                </div>
            </div>
        </div>
        
        <div class="content" id="content">
            <p style="text-align: center; padding: 40px; color: #666;">
                × × ×œ×”×–×™×Ÿ ×©× ××©×ª××© ×›×“×™ ×œ×”×ª×—×™×œ
            </p>
        </div>
        
        <div class="footer">
            <div class="footer-info" id="filePathInfo"></div>
            <div class="footer-info" id="commitInfo">Loading version info...</div>
        </div>
    </div>

    <script>
        // Client state - ONLY current record, never full dataset
        let currentRecord = null;
        let originalRecord = null; // For change detection
        let currentIndex = null;
        let hasChanges = false;
        let username = '';
        let dataVersion = null;
        let isAdmin = false;
        let lastStatsUpdate = null;
        let pendingUpdates = [];
        let isProcessingUpdates = false;
        let historyStack = [];
        let lastFilters = { status: '', llm: '' };
        let sessionId = sessionStorage.getItem('sessionId') || '';
        const matchedWordPalette = [
            '#fff59d', // soft yellow
            '#b3e5fc', // light blue
            '#c8e6c9', // light green
            '#ffccbc', // light orange
            '#d1c4e9', // light purple
            '#f8bbd0', // light pink
            '#c5cae9', // light indigo
            '#ffe0b2'  // light amber
        ];

        function deepCopy(value) {
            return JSON.parse(JSON.stringify(value));
        }

        function escapeRegExp(text) {
            return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function highlightMatchedWords(text, words) {
            const colorMap = new Map();
            let colorIndex = 0;

            words.forEach(word => {
                if (!word) return;
                if (!colorMap.has(word)) {
                    colorMap.set(word, matchedWordPalette[colorIndex % matchedWordPalette.length]);
                    colorIndex += 1;
                }
            });

            let highlighted = text;
            words.forEach(word => {
                if (!word) return;
                const color = colorMap.get(word);
                const regex = new RegExp('(' + escapeRegExp(word) + ')', 'g');
                highlighted = highlighted.replace(regex, `<span style="background-color: ${color}; padding: 2px 4px; border-radius: 2px;">$1</span>`);
            });

            return highlighted;
        }

        function getActiveFilters() {
            return {
                status: document.getElementById('filterStatus')?.value || '',
                llm: document.getElementById('filterLLMStatus')?.value || ''
            };
        }

        async function ensureUsername() {
            if (username) return true;
            username = prompt('Enter your username:', '');
            if (!username) {
                alert('Username is required to use the application');
                return false;
            }
            if (!sessionId) {
                sessionId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : `sess_${Date.now()}_${Math.random().toString(16).slice(2)}`;
                sessionStorage.setItem('sessionId', sessionId);
            }
            return true;
        }

        function buildHeaders(extra = {}) {
            return Object.assign({
                'X-Username': username,
                'X-Session-Id': sessionId
            }, extra);
        }

        // Check if user is admin
        async function checkAdminStatus() {
            try {
                const response = await fetch('/health');
                const result = await response.json();
                const adminUser = result.admin_user || 'danny';
                isAdmin = (username === adminUser);

                // Enable/disable upload and download buttons
                const uploadBtn = document.getElementById('uploadBtn');
                const downloadBtn = document.getElementById('downloadBtn');
                const forceSaveBtn = document.getElementById('forceSaveBtn');

                if (uploadBtn && downloadBtn && forceSaveBtn) {
                    uploadBtn.disabled = !isAdmin;
                    downloadBtn.disabled = !isAdmin;
                    forceSaveBtn.disabled = !isAdmin;

                    if (!isAdmin) {
                        uploadBtn.title = `Only ${adminUser} can upload files`;
                        downloadBtn.title = `Only ${adminUser} can download files`;
                        forceSaveBtn.title = `Only ${adminUser} can force save`;
                    } else {
                        uploadBtn.title = 'Upload new JSON file to server';
                        downloadBtn.title = 'Download current JSON file from server';
                        forceSaveBtn.title = 'Force immediate save to disk (ignores auto-save schedule)';
                    }
                }
            } catch (error) {
                console.error('Failed to check admin status:', error);
            }
        }

        // Upload file to server (admin only)
        async function uploadFileToServer(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!isAdmin) {
                alert('Only admin users can upload files');
                return;
            }

            try {
                const formData = new FormData();
                formData.append('file', file);

                const response = await fetch('/upload', {
                    method: 'POST',
                    headers: buildHeaders(),
                    body: formData
                });

                const result = await response.json();

                if (response.ok) {
                    const message = `File uploaded successfully! ${result.items} items loaded.`;
                    const pathInfo = result.saved_to ? `
Saved to: ${result.saved_to}` : '';
                    alert(message + pathInfo);

                    // Update footer with file path
                    if (result.saved_to) {
                        document.getElementById('filePathInfo').innerHTML =
                            `<strong>Data file location:</strong> ${result.saved_to}`;
                    }

                    historyStack = [];
                    currentIndex = null;
                    await fetchNextRecord({ reset: true });
                } else {
                    alert(`Upload failed: ${result.detail || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Upload error:', error);
                alert('Failed to upload file. Check console for details.');
            }

            // Reset file input
            event.target.value = '';
        }

        // Download file from server (admin only)
        async function downloadFromServer() {
            if (!isAdmin) {
                alert('Only admin users can download files');
                return;
            }

            try {
                // First, save any current unsaved changes on the current record
                saveChanges();

                // Wait for all pending updates to complete first
                showSaveIndicator('â³ Flushing pending updates to server...', 'warning', 10000);
                await flushPendingUpdates();
                showSaveIndicator('ğŸ“¥ Downloading from server...', 'success', 2000);

                const response = await fetch('/download', {
                    headers: buildHeaders()
                });

                if (response.ok) {
                    const filePath = response.headers.get('X-File-Path');
                    const unsavedChanges = response.headers.get('X-Unsaved-Changes');
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    a.download = `tmp_lh_links_${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);

                    const msg = unsavedChanges > 0
                        ? `âœ… Downloaded (${unsavedChanges} unsaved changes included)`
                        : 'âœ… Downloaded successfully';
                    showSaveIndicator(msg, 'success', 3000);

                    // Show file path info
                    if (filePath) {
                        document.getElementById('filePathInfo').innerHTML =
                            `<strong>Data file location:</strong> ${filePath}`;
                    }
                } else {
                    const result = await response.json();
                    alert(`Download failed: ${result.detail || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Download error:', error);
                alert('Failed to download file. Check console for details.');
            }
        }

        // Force save to server (admin only)
        async function forceSaveToServer() {
            if (!isAdmin) {
                alert('Only admin users can force save');
                return;
            }

            if (!confirm('Force save all unsaved changes to disk now?')) {
                return;
            }

            try {
                // First, save any current unsaved changes on the current record
                saveChanges();

                // Wait for all pending updates to complete first
                showSaveIndicator('â³ Flushing pending updates to server...', 'warning', 10000);
                await flushPendingUpdates();

                showSaveIndicator('ğŸ’¾ Writing to disk...', 'warning', 3000);

                const response = await fetch('/force-save', {
                    method: 'POST',
                    headers: buildHeaders()
                });

                const result = await response.json();

                if (response.ok) {
                    const msg = `âœ… Saved to disk: ${result.modifications_saved} modifications, ${result.file_size} bytes`;
                    showSaveIndicator(msg, 'success', 5000);
                    console.log('Force save result:', result);
                    // Refresh stats from server after save
                    await updateStats();
                } else {
                    showSaveIndicator(`âŒ ${result.detail || 'Save failed'}`, 'error', 5000);
                }
            } catch (error) {
                console.error('Force save error:', error);
                showSaveIndicator('âŒ Failed to force save. Check console for details.', 'error', 5000);
            }
        }

        async function loadDataFromServer() {
            if (!(await ensureUsername())) {
                return;
            }

            // Update header with username
            const header = document.querySelector('.header h1');
            header.textContent = `Linking (User: ${username})`;

            // Check admin status and enable/disable buttons
            checkAdminStatus();

            await fetchNextRecord({ reset: true });
            await updateStats();
        }

        async function fetchNextRecord({ reset = false } = {}) {
            if (!(await ensureUsername())) {
                return;
            }
            if (hasChanges && !confirm('×™×© ×©×™× ×•×™×™× ×©×œ× × ×©××¨×•. ×”×× ×œ×”××©×™×š?')) {
                return;
            }

            const filters = getActiveFilters();
            if (reset) {
                historyStack = [];
            }

            try {
                const params = new URLSearchParams({
                    current_index: currentIndex === null || reset ? -1 : currentIndex
                });
                if (filters.status) params.append('filter_status', filters.status);
                if (filters.llm) params.append('filter_llm_status', filters.llm);

                const response = await fetch(`/next?${params}`, {
                    headers: buildHeaders()
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();

                if (result.index !== null && result.index !== undefined) {
                    if (!reset && currentIndex !== null) {
                        historyStack.push(currentIndex);
                    }
                    setCurrentRecord(result.index, result.record);
                    updateStats();

                    if (result.occupied_count > 0) {
                        console.log(`Skipped ${result.occupied_count} records being viewed by other users`);
                    }
                } else {
                    alert(result.message || 'No more records available');
                }
            } catch (error) {
                console.error('Error getting next record:', error);
                alert('Error getting next record. Check console for details.');
            }
        }

        async function fetchRecordByIndex(index, { pushHistory = true } = {}) {
            if (index === null || index < 0) {
                alert('Invalid record number');
                return;
            }

            if (!(await ensureUsername())) {
                return;
            }

            try {
                const response = await fetch(`/record?index=${index}`, {
                    headers: buildHeaders()
                });

                if (response.status === 409) {
                    const result = await response.json();
                    alert(result.detail || 'That record is currently in use by another user.');
                    return;
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                if (result.index !== null && result.record) {
                    if (pushHistory && currentIndex !== null) {
                        historyStack.push(currentIndex);
                    }
                    setCurrentRecord(result.index, result.record);
                    updateStats();
                }
            } catch (error) {
                console.error('Error getting record:', error);
                alert('Error getting record. Check console for details.');
            }
        }

        function setCurrentRecord(index, record) {
            currentIndex = index;
            currentRecord = record;
            originalRecord = deepCopy(record);
            hasChanges = false;

            displayItem(index);
            updateNavigation();
        }

        function displayItem(index) {
            if (!currentRecord) return;

            const item = currentRecord;

            // Main header links
            let html = `
                <div class="main-links">
                    <div class="link-column">
                        <a href="${item.RefALink}" target="_blank" class="main-link">${item.RefA}</a>
                    </div>
                    <div class="link-column">
                        <a href="${item.RefBExactLink}" target="_blank" class="main-link">${item.RefBExact}</a>
                    </div>
                </div>
            `;

            // Match details section (above snippets, bold)
            html += '<div class="match-details">';
            html += `<strong>Type:</strong> ${item.MatchType} | `;
            html += `<strong>Score:</strong> ${item.DeterministicScore} | `;
            html += `<strong>Matched:</strong> ${item.MatchedWords}`;
            html += '</div>';

            // Two column layout for RefA/RefB content
            html += '<div class="two-column-layout">';

            // Left column - RefA content
            html += '<div class="column">';
            html += '<div class="field-group">';
            html += '<label class="field-label">Snippet (Likutei Halakhot)</label>';

            // Highlight matched words in the snippet
            let snippetText = item.LHSnippet || '';
            let matchedWords = (item.MatchedWords || '').split(' ').filter(w => w.trim());
            let highlightedSnippet = snippetText;

            // Extract the chapter number from RefB (e.g., "Likutei Moharan.61" -> 61)
            let refBChapter = null;
            if (item.RefB) {
                const refBParts = item.RefB.split('.');
                if (refBParts.length > 1) {
                    refBChapter = parseInt(refBParts[refBParts.length - 1], 10);
                }
            }

            // Hebrew gematria function to convert Hebrew numbers
            function hebrewGematria(str) {
                const gematriaMap = {
                    '×': 1, '×‘': 2, '×’': 3, '×“': 4, '×”': 5, '×•': 6, '×–': 7, '×—': 8, '×˜': 9,
                    '×™': 10, '×›': 20, '×š': 20, '×œ': 30, '×': 40, '×': 40, '× ': 50, '×Ÿ': 50,
                    '×¡': 60, '×¢': 70, '×¤': 80, '×£': 80, '×¦': 90, '×¥': 90, '×§': 100, '×¨': 200,
                    '×©': 300, '×ª': 400
                };
                let total = 0;
                for (let c of str) {
                    total += gematriaMap[c] || 0;
                }
                return total;
            }

            // Highlight "×‘×¡×™××Ÿ" and following words - dark green if matches RefB chapter, light green otherwise
            const simanPattern = /(×¡×™××Ÿ\s+([×-×ªÖ‘-×‡"×³×´'()]+)(?:\s+[×-×ªÖ‘-×‡"×³×´'()]+){0,3})/g;
            highlightedSnippet = highlightedSnippet.replace(simanPattern, (match, fullMatch, simanNumber) => {
                // Extract just the Hebrew letters from the siman number
                const cleanSiman = simanNumber.replace(/[Ö‘-×‡"×³×´'()]/g, '');
                const simanValue = hebrewGematria(cleanSiman);

                // Use dark green if it matches the RefB chapter, light green otherwise
                const bgColor = (refBChapter && simanValue === refBChapter) ? '#2e7d32' : '#c8e6c9';
                const textColor = (refBChapter && simanValue === refBChapter) ? 'white' : 'inherit';
                return `<span style="background-color: ${bgColor}; color: ${textColor}; font-weight: bold;">${fullMatch}</span>`;
            });

            // Then highlight each matched word with distinct colors
            highlightedSnippet = highlightMatchedWords(highlightedSnippet, matchedWords);

            html += `<div class="field-value large" style="white-space: pre-wrap;">${highlightedSnippet}</div>`;
            html += '<button class="btn btn-verify-next" style="margin-top: 15px; padding: 12px 24px; font-size: 16px; font-weight: bold; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;" onclick="verifyAndNext()">âœ“ Mark Verified and Save &gt;&gt;</button>';
            html += '</div>';

            html += '</div>';

            // Right column - RefB content
            html += '<div class="column">';
            html += '<div class="field-group">';
            html += `<label class="field-label">RefB: <a href="${item.RefBLink}" target="_blank" class="link">${item.RefB}</a></label>`;

            // Highlight matched words in LM snippet
            let lmSnippetText = item.LMSnippet || '';
            let highlightedLM = lmSnippetText;
            highlightedLM = highlightMatchedWords(highlightedLM, matchedWords);

            html += `<div class="field-value large refb-display" style="white-space: pre-wrap;">${highlightedLM}</div>`;
            html += `<textarea class="field-value large editable refb-edit" data-field="LMSnippet" style="display: none;">${lmSnippetText}</textarea>`;
            html += '<button class="btn refb-edit-btn" style="margin-top: 10px;" onclick="toggleRefBEdit()">×¢×¨×•×š</button>';
            html += '</div>';
            html += '<div class="field-group">';
            html += '<label class="field-label">RefBExact (editable)</label>';
            html += `<input type="text" class="field-value editable" data-field="RefBExact" value="${item.RefBExact || ''}" onfocus="this.select()" onpaste="handleRefBExactPaste(event)" onchange="updateRefBExactLink(this)">`;
            html += '</div>';

            html += '<div class="field-group">';
            html += '<label class="field-label" style="font-weight: bold; font-size: 15px;">Status</label>';
            html += '<select class="field-value editable" data-field="Status" style="font-weight: bold;">';
            const statusOptions = ['Pending', 'done', 'verified', 'rejected'];
            statusOptions.forEach(opt => {
                const selected = opt === item.Status ? 'selected' : '';
                html += `<option value="${opt}" ${selected}>${opt}</option>`;
            });
            html += '</select>';
            html += '</div>';

            html += `
                <div class="actions" style="margin-top: 20px; padding-top: 0; border-top: none;">
                    <button class="btn btn-save" onclick="saveChanges()">×©××•×¨ ×©×™× ×•×™×™×</button>
                    <button class="btn btn-cancel" onclick="cancelChanges()">×‘×˜×œ ×©×™× ×•×™×™×</button>
                </div>
            `;
            html += '</div>';

            html += '</div>'; // End two-column-layout

            document.getElementById('content').innerHTML = html;

            // Add change listeners
            document.querySelectorAll('.editable').forEach(input => {
                input.addEventListener('change', () => hasChanges = true);
            });
        }

        function updateNavigation() {
            document.getElementById('counter').textContent =
                currentIndex !== null ? `Record ${currentIndex + 1}` : '0 / 0';
            document.getElementById('prevBtn').disabled = historyStack.length === 0;
            document.getElementById('nextBtn').disabled = currentIndex === null;
        }

        function updateFilters() {
            const filters = getActiveFilters();
            const hasFilters = filters.status || filters.llm;

            const filterCounter = document.getElementById('filterCounter');
            if (hasFilters) {
                filterCounter.textContent = `(filtered by server)`;
            } else {
                filterCounter.textContent = '';
            }

            if (filters.status !== lastFilters.status || filters.llm !== lastFilters.llm) {
                lastFilters = filters;
                fetchNextRecord({ reset: true });
            }
        }

        async function gotoItem() {
            const input = document.getElementById('gotoInput');
            const itemNumber = parseInt(input.value, 10);

            if (isNaN(itemNumber) || itemNumber < 1) {
                alert('× × ×œ×”×–×™×Ÿ ××¡×¤×¨ ×ª×§×™×Ÿ');
                return;
            }

            if (hasChanges && !confirm('×™×© ×©×™× ×•×™×™× ×©×œ× × ×©××¨×•. ×”×× ×œ×”××©×™×š?')) {
                return;
            }

            await fetchRecordByIndex(itemNumber - 1);
            input.value = '';
        }

        async function previousItem() {
            if (historyStack.length === 0) {
                return;
            }

            if (hasChanges && !confirm('×™×© ×©×™× ×•×™×™× ×©×œ× × ×©××¨×•. ×”×× ×œ×”××©×™×š?')) {
                return;
            }

            const previousIndex = historyStack.pop();
            await fetchRecordByIndex(previousIndex, { pushHistory: false });
        }

        async function nextItem() {
            await fetchNextRecord();
        }

        function saveChanges() {
            if (currentIndex === null || !currentRecord) return;

            const editableFields = document.querySelectorAll('.editable');
            const updates = {};

            editableFields.forEach(input => {
                const fieldName = input.dataset.field;
                const newValue = input.value;
                const oldValue = originalRecord ? originalRecord[fieldName] : '';

                // Track if value changed compared to original server state
                if (newValue !== oldValue) {
                    updates[fieldName] = newValue;
                }
            });

            // If there are changes, queue the update
            if (Object.keys(updates).length > 0) {
                queueUpdate(currentIndex, updates);

                // Update local record snapshot
                Object.keys(updates).forEach(key => {
                    currentRecord[key] = updates[key];
                    originalRecord[key] = updates[key];
                });

                // Refresh stats from server after update
                setTimeout(() => updateStats(), 500);
                showSaveIndicator('âœ“ ×©×™× ×•×™×™× × ×©××¨×•', 'success', 1000);
            }

            hasChanges = false;
        }

        function cancelChanges() {
            if (hasChanges && !confirm('×”×× ×œ×‘×˜×œ ××ª ×›×œ ×”×©×™× ×•×™×™×?')) {
                return;
            }
            if (originalRecord) {
                currentRecord = deepCopy(originalRecord);
            }
            displayItem(currentIndex);
            hasChanges = false;
        }

        function saveAndNext() {
            saveChanges();
            setTimeout(() => {
                nextItem();
            }, 100);
        }

        function verifyAndNext() {
            // Set status to verified in the UI
            const statusSelect = document.querySelector('select[data-field="Status"]');
            if (statusSelect) {
                statusSelect.value = 'verified';
            }

            saveChanges();

            setTimeout(() => {
                nextItem();
            }, 100);
        }

        function toggleRefBEdit() {
            const displayDiv = document.querySelector('.refb-display');
            const editArea = document.querySelector('.refb-edit');
            const button = document.querySelector('.refb-edit-btn');

            if (editArea.style.display === 'none') {
                // Switch to edit mode
                displayDiv.style.display = 'none';
                editArea.style.display = 'block';
                button.textContent = '×©××•×¨';
            } else {
                // Switch to display mode
                displayDiv.textContent = editArea.value;
                displayDiv.style.display = 'block';
                editArea.style.display = 'none';
                button.textContent = '×¢×¨×•×š';
                hasChanges = true;
            }
        }

        function updateRefBExactLink(input) {
            const newValue = input.value.trim();

            // Check if it's a URL (contains sefaria.org or starts with http)
            if (newValue.includes('sefaria.org') || newValue.startsWith('http')) {
                try {
                    // Parse the URL and remove query parameters
                    const url = new URL(newValue);
                    const pathParts = url.pathname.split('/').filter(p => p);

                    // Extract the reference (usually the last part of the path)
                    if (pathParts.length > 0) {
                        const ref = decodeURIComponent(pathParts[pathParts.length - 1]);

                        // Update RefBExact with the cleaned reference
                        input.value = ref;

                        // Construct the clean link without query params
                        const cleanLink = url.origin + url.pathname;

                        // Update the RefBExactLink field if it exists
                        const linkField = document.querySelector('input[data-field="RefBExactLink"]');
                        if (linkField) {
                            linkField.value = cleanLink;
                        }

                        hasChanges = true;
                    }
                } catch (e) {
                    console.error('Error parsing URL:', e);
                }
            } else {
                // If not a URL, value is already in input
                hasChanges = true;
            }
        }

        function handleRefBExactPaste(event) {
            event.preventDefault();
            const pastedText = (event.clipboardData || window.clipboardData).getData('text').trim();
            const input = event.target;

            console.log('Pasted text:', pastedText);

            // Check if it's a Sefaria URL
            if (pastedText.includes('sefaria.org')) {
                try {
                    // Parse the URL and remove query parameters
                    const url = new URL(pastedText);
                    console.log('Parsed URL:', url);
                    console.log('Pathname:', url.pathname);

                    const pathParts = url.pathname.split('/').filter(p => p);
                    console.log('Path parts:', pathParts);

                    // Extract the reference (usually the last part of the path)
                    if (pathParts.length > 0) {
                        const ref = decodeURIComponent(pathParts[pathParts.length - 1]);

                        // Update the input field with the cleaned reference
                        input.value = ref;

                        // Construct the clean link without query params
                        const cleanLink = url.origin + url.pathname;

                        // Update the RefBExactLink field if it exists
                        const linkField = document.querySelector('input[data-field="RefBExactLink"]');
                        if (linkField) {
                            linkField.value = cleanLink;
                        }

                        // Mark that we have unsaved changes
                        hasChanges = true;

                        // Fetch the LM snippet from the server
                        fetch(`/lm-paragraph/${encodeURIComponent(ref)}`)
                            .then(response => response.json())
                            .then(result => {
                                if (result.text) {
                                    // Update the UI elements (but NOT currentRecord yet)
                                    const refbDisplay = document.querySelector('.refb-display');
                                    const refbEdit = document.querySelector('.refb-edit');
                                    const refbEditBtn = document.querySelector('.refb-edit-btn');

                                    if (refbDisplay && refbEdit) {
                                        // Update the textarea value so saveChanges() can detect it
                                        refbEdit.value = result.text;

                                        // Highlight matched words in the snippet
                                        let matchedWords = (currentRecord?.MatchedWords || '').split(' ').filter(w => w.trim());
                                        let highlightedText = highlightMatchedWords(result.text, matchedWords);

                                        // Update display area
                                        refbDisplay.innerHTML = highlightedText;

                                        // Ensure display mode is visible
                                        refbDisplay.style.display = 'block';
                                        refbEdit.style.display = 'none';
                                        if (refbEditBtn) refbEditBtn.textContent = '×¢×¨×•×š';
                                    }

                                    console.log('âœ“ Fetched and updated LMSnippet');
                                } else {
                                    console.warn('No text found for reference:', ref);
                                    const refbEdit = document.querySelector('.refb-edit');
                                    if (refbEdit) {
                                        refbEdit.value = '';
                                    }
                                }
                            })
                            .catch(error => {
                                console.error('Error fetching LM paragraph:', error);
                                const refbDisplay = document.querySelector('.refb-display');
                                const refbEdit = document.querySelector('.refb-edit');
                                if (refbEdit) {
                                    refbEdit.value = '';
                                }
                                if (refbDisplay) {
                                    refbDisplay.textContent = 'Error fetching paragraph: ' + error.message;
                                    refbDisplay.style.display = 'block';
                                }
                                if (refbEdit) {
                                    refbEdit.value = '';
                                    refbEdit.style.display = 'none';
                                }
                            });

                        // Change status to verified
                        const statusSelect = document.querySelector('select[data-field="Status"]');
                        if (statusSelect) statusSelect.value = 'verified';

                        hasChanges = true;

                        // Update the main link button at the top
                        const mainLinkButtons = document.querySelectorAll('.main-link');
                        if (mainLinkButtons.length >= 2) {
                            const refBExactLinkButton = mainLinkButtons[1];
                            refBExactLinkButton.href = cleanLink;
                            refBExactLinkButton.textContent = ref;
                        }

                        console.log('âœ“ Extracted RefBExact:', ref);
                        console.log('âœ“ Clean link:', cleanLink);
                        console.log('âœ“ Status set to verified');
                        console.log('âœ“ Updated main link button');

                        // Flash the input to show it worked
                        input.style.backgroundColor = '#c8e6c9';
                        setTimeout(() => {
                            input.style.backgroundColor = '';
                        }, 500);
                    }
                } catch (e) {
                    console.error('Error parsing URL:', e);
                    // Fallback to normal paste
                    input.value = pastedText;
                }
            } else {
                // Normal paste for non-URL text
                console.log('Not a Sefaria URL, pasting normally');
                input.value = pastedText;
                hasChanges = true;
            }
        }

        // Stats polling and display functions
        async function updateStats() {
            try {
                const response = await fetch('/stats', {
                    headers: buildHeaders()
                });

                if (response.ok) {
                    const stats = await response.json();
                    lastStatsUpdate = stats;

                    const totalEl = document.getElementById('statTotalRecords');
                    const pendingEl = document.getElementById('statPending');
                    const verifiedEl = document.getElementById('statVerified');
                    const unsavedEl = document.getElementById('statUnsaved');
                    const lastSaveEl = document.getElementById('statLastSave');

                    if (totalEl) {
                        totalEl.textContent = stats.total_records || 0;
                    }
                    if (pendingEl) {
                        pendingEl.textContent = (stats.by_status && stats.by_status.Pending) || 0;
                    }
                    if (verifiedEl) {
                        verifiedEl.textContent = (stats.by_status && stats.by_status.verified) || 0;
                    }
                    if (unsavedEl) {
                        unsavedEl.textContent = stats.unsaved_changes || 0;
                        if (stats.unsaved_changes > 5) {
                            unsavedEl.classList.add('pending');
                        } else {
                            unsavedEl.classList.remove('pending');
                        }
                    }

                    // Format last save time
                    if (stats.last_save && lastSaveEl) {
                        const lastSave = new Date(stats.last_save);
                        const now = new Date();
                        const diffMinutes = Math.floor((now - lastSave) / 60000);
                        let timeStr = diffMinutes === 0 ? 'Just now' :
                                     diffMinutes === 1 ? '1 min ago' :
                                     diffMinutes < 60 ? `${diffMinutes} mins ago` :
                                     lastSave.toLocaleTimeString();
                        lastSaveEl.textContent = timeStr;
                    } else if (lastSaveEl) {
                        lastSaveEl.textContent = 'Never';
                    }

                    if (stats.last_save_error) {
                        showSaveIndicator('âš ï¸ Auto-save failed: ' + stats.last_save_error, 'error', 5000);
                    }

                    document.getElementById('statsPanel').style.display = 'flex';
                }
            } catch (error) {
                console.error('Failed to fetch server stats:', error);
                document.getElementById('statsPanel').style.display = 'flex';
            }
        }

        function showSaveIndicator(message, type = 'success', duration = 2000) {
            const indicator = document.getElementById('saveIndicator');
            indicator.textContent = message;
            indicator.className = 'save-indicator show';

            if (type === 'warning') {
                indicator.classList.add('warning');
            } else if (type === 'error') {
                indicator.classList.add('error');
            }

            setTimeout(() => {
                indicator.classList.remove('show');
                setTimeout(() => {
                    indicator.className = 'save-indicator';
                }, 300);
            }, duration);
        }

        // Batched update system - queues updates and sends them efficiently
        async function queueUpdate(index, updates) {
            pendingUpdates.push({ index, updates });

            // Process updates if not already processing
            if (!isProcessingUpdates) {
                processUpdates();
            }
        }

        async function processUpdates() {
            if (pendingUpdates.length === 0) {
                isProcessingUpdates = false;
                return;
            }

            isProcessingUpdates = true;

            // Get next update from queue
            const update = pendingUpdates.shift();

            try {
                const response = await fetch('/update', {
                    method: 'POST',
                    headers: buildHeaders({ 'Content-Type': 'application/json' }),
                    body: JSON.stringify(update)
                });

                if (response.ok) {
                    const result = await response.json();
                    dataVersion = result.version;

                    // Show minimal feedback
                    if (result.modification_count % 5 === 0) {
                        showSaveIndicator(`âœ“ ${result.modification_count} changes queued`, 'success', 1000);
                        // Update stats on every 5th change
                        updateStats();
                    }
                } else {
                    console.error('Update failed:', await response.text());
                    showSaveIndicator('âš ï¸ Update failed', 'error', 2000);
                }
            } catch (error) {
                console.error('Update error:', error);
                showSaveIndicator('âš ï¸ Update error', 'error', 2000);
            }

            // Continue processing if there are more updates
            setTimeout(() => processUpdates(), 50);
        }

        // Wait for all pending updates to complete
        async function flushPendingUpdates() {
            return new Promise((resolve) => {
                const checkQueue = () => {
                    if (pendingUpdates.length === 0 && !isProcessingUpdates) {
                        resolve();
                    } else {
                        setTimeout(checkQueue, 100);
                    }
                };
                checkQueue();
            });
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    nextItem();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    previousItem();
                } else if (e.key === 's') {
                    e.preventDefault();
                    saveChanges();
                } else if (e.key === 'g') {
                    e.preventDefault();
                    document.getElementById('gotoInput').focus();
                }
            } else if (e.shiftKey && e.key === 'Enter') {
                e.preventDefault();
                saveAndNext();
            } else if (e.key === 'Enter' && document.activeElement.id === 'gotoInput') {
                e.preventDefault();
                gotoItem();
            }
        });

        // Initialize on page load
        window.onload = function() {
            // Load commit info
            loadCommitInfo();

            // Try to load from server first
            loadDataFromServer().catch(() => {
                console.log('JSON Viewer loaded.');
            });
        };

        // Load git commit information
        async function loadCommitInfo() {
            try {
                const response = await fetch('/health');
                if (response.ok) {
                    const data = await response.json();
                    // Try to get commit from environment or build info
                    const commitInfo = data.commit || data.version || 'unknown';
                    document.getElementById('commitInfo').innerHTML =
                        `<strong>Version:</strong> ${commitInfo.substring(0, 8)} | <strong>Updated:</strong> ${new Date(data.timestamp).toLocaleString()}`;
                }
            } catch (error) {
                console.log('Could not load commit info:', error);
                document.getElementById('commitInfo').textContent = '';
            }
        }
    </script>
</body>
</html>
